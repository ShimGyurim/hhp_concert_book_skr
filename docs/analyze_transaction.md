## 현재 시스템 트랜잭션 범위 분석 및 확장이 용이토록 개선할 점 분석

1. 분석 대상 유스케이스: 콘서트 예약 / 콘서트 결제 
2. 개선 사유 : 
    1. 지나치게 긴 트랜잭션으로 인해 이후 서비스에 지연이 발생 가능 
    2. 같은 트랜잭션에 묶여 있으면 하나 비정상 처리 시 모두 롤백 처리될 위험이 있음 (굳이 모두 롤백할 필요가 없음에도 불구한 경우에도)
    3. scale-up 시에 서비스가 모두 같은 DB나 인스턴스에서 실행되지 않을 상황이 올 수도 있음 

### <콘서트 예약>

---

1. AS-IS (현재코드) 

BookFacade 

(트랜잭션 시작)

- 토큰 검증
- 좌석 정보 로드
- 사용자 정보 로드
- 예약 정보 생성
- 토큰 삭제 처리

(트랜잭션 끝)

2. TO-BE (변경예정코드)

A. 고려사항 (한계 / 해결책) : 

- 트랜잭션은 될수있으면 **작은 단위로 나누는 게 좋겠다고 판단** 
    - 사유:
        - 확장 시 facade 내의 service 가 추가될 가능성이 있으며, 각 service 중 하나가 실패 혹은 지연의 위험 존재
        - 서비스 별로 별도의 db 사용 가능
        - 서비스를 MQ 등을 이용해 호출할 경우 같은 트랜잭션에 놓기 어려움  
- **부차적인 기능은 모두 이벤트 발생해서 처리**.
    - 메인 서비스가 커밋 완료 후 비동기적으로 작동
- 메인 기능은 예약정보 생성 하나뿐이라 해당 서비스 내에서 트랜잭션 오픈하는걸로 변경
- 트랜잭션이 나누어 지므로 원활한 동시성 제어를 위해 facade 내에서 분산락 적용 (key = 콘서트좌석id 단위)

B. 구현

<try>

(분산락 잠금  / key=콘서트좌석id) 

- 토큰 검증
- 좌석 정보 로드
- 사용자 정보 로드
- 예약 정보 생성_TX {
  
    예약정보생성 : 서비스 내부 로컬 트랜잭션
  
} 

- 토큰 삭제 처리 → 이벤트 발행
- 외부 api 호출 → 이벤트 발행

<finally 부분>

(분산락 해제) 

이벤트_리스너 { 

토큰삭제처리 실행 : AFTER_COMMIT  & ASYNC

외부 api 호출 : AFTER_COMMIT & ASYNC 

}

C. 비고

- 주 로직이 예약정보 생성 뿐이라 별도 보상 트랜잭션은 불필요하다고 판단
- **예외 발생으로 인해 분산락 미 해제 위험이 있으므로** finally 부분에서 해제

### <콘서트 결제>

---

1. AS-IS (현재코드) 

PayFacade

(트랜잭션 시작)

- 토큰 검증
- 예약 정보 로드
- 잔액정보 로드
- 잔액 차감
- 결제 정보 생성 (결제 처리)
- 예약 상태 변경 (가 예약 → 결제완료)
- 토큰 삭제

(트랜잭션 끝) 

2. TO-BE (변경예정코드)

a. 고려사항 (한계 / 해결책) : 

- 트랜잭션은 서비스 단위로 나눔
- (주 서비스인) 잔액차감 / 결제정보 생성 / 예약상태변경 중 하나라도 실패 시 모두 실패 처리 → **보상트랜잭션 처리**
- 주 서비스들을 비동기 이벤트로 처리 시 원자성 보장이 매우 힘들어짐. => **완전한 병렬처리는 안함. 이벤트를 사용하더라도 순서에 맞춰 서비스 호출** 
- 주 서비스 실패(예외발생) ~ 보상트랜잭션 가동 전의 찰나에 다른 사용자가 임계공간에 접근하여 데이터 변경에 대해서도 고려 필요 => **모든 로직의 처리가 끝날때까지 분산락을 해제하면 안됨 (보상트랜잭션으로도 롤백 불가한 상황이 올 수도 있음)**
- 보상 트랜잭션은 커스텀 예외 값에 따라 맞는 로직이 작동 (예시: userException.PayExcetion 인 경우 해당 로직에 맞는 보상트랜잭션 로직 호출)

b. 구현

<try>

**(분산락 잠금)**

- 토큰 검증
- 예약 정보 로드
- 잔액정보 로드
- 잔액차감_TRANSACTION {
  
    잔액차감 처리
  
}

- 결제정보생성_TRANSACTION {
  
    결제정보생성
  
}

- **예약정보변경_TRANSACTION {**
    
    예약 상태 변경 (가 예약 → 결제완료)
    
**}** 

- 토큰 삭제 ⇒ **비동기 이벤트 처리**
- 외부 api 호출 ⇒ **비동기 이벤트 처리**

<catch>

- 예외 시 보상 트랜잭션 호출

CASE exception = 잔액 차감 예외 발생 

- 결제 정보 생성 롤백 ⇒ **비동기 이벤트 처리**
- 예약 상태 변경 롤백 ⇒ **비동기 이벤트 처리**

CASE exception = 결제 정보 생성 예외 

- 잔액 차감 롤백 ⇒ **비동기 이벤트 처리**
- 예약 상태 변경 롤백 ⇒ **비동기 이벤트 처리**

CASE exception = 예약 상태 변경 예외

- 잔액 차감 롤백 ⇒ **비동기 이벤트 처리**
- 결제 정보 생성 롤백 ⇒ **비동기 이벤트 처리**

<finally> 

**(분산락 해제)**

후처리_이벤트_리스너 {

토큰삭제 : AFTER_COMMIT & ASYNC

외부 API 호출: AFTER_COMMIT & ASYNC

}

예외이벤트_리스너 {

잔액차감예외 ( 잔액예외이벤트) : ASYNC

예약변경예외 (예약예외이벤트) : ASYNC

결제정보생성예외 (결제예외이벤트) : ASYNC

}

c. 비고 

- saga 패턴의 개념을 일부 차용하여 각 로컬 트랜잭션에 대한 보상 트랜잭션 구현
- 덜 중요한 로직인 토큰 삭제 및 외부 api 호출 등은 로컬 트랜잭션 완료 시 비동기 이벤트 호출하여 관심사 분리
